:imagesdir: Images
:figure-caption: Рисунок
== Лабораторная работа 1

=== Задание
* Создать проект  *Lab1* (С++ с main) с настройками под микроконтроллер *STM32F411RE*.
* Сделать программу, которая считает сумму двух char чисел (например *1* и *-6*, *10* и *250*). Вывести результат в *Terminal I/O*. Объяснить результат.
* Запустить проект на выполнение по симулятором, посмотреть листинг дизамблера - попробовать определить где создались ваши переменные.
* Проверить все переменные в окне *Watch*, сделать пошаговую отладку (F10, F11), посмотреть, как меняются переменные в окне *Watch*. заупустить окно *Registers* и посмотреть значения регистров в которых созданы переменные.

---

=== Создание проекта и работа в IAR Workbench
* Создадим новый проект Project=>Create New Project.

.Создание нового проекта
image::1.png[]
* Выбираем шаблон проекта( ProjectTemplates): C++ - main

.Выбор шаблона проекта
image::2.png[]

=== Выбор микроконтроллера STM32F411RE
* В свойствах проекта выбираем модель микроконтроллера ST ⇒ STM32F4⇒ STM32F411⇒ ST STM32F411RE (рисунок 3). Для этого правой кнопкой мыши щелкнуть по проекту, выбирать Options и далее в категории General Option выбрать закладку Target.

.Выбор микроконтроллера
image::3.png[]

=== Запуск в режиме отладки
После создания проекта необходимо сохранить так называемое рабочее пространство или (workspace).

После того, как проект сделан, и имеет вид показанный на рисунке 4, попробуем собрать проект, нажав кнопку _Ctrl-F7_, а затем запустим на отладку с помощью кнопки _Ctrl-D_.

.Вид созданного проекта
image::4.png[]

=== Написание программы

* Программа считает сумму двух char чисел (например *1* и *-6*, *10* и *250*). Код программы показан на рисунке 5.

.Код программы
image::5.png[]

* Выведем результат в *Terminal I/O*.

.Результат в окне Terminal I/O
image::6.png[]

Переменная типа char занимает 1 байт. Однако вместо конвертации значения типа char в целое число, оно интерпретируется как ASCII-символ, поэтому в терминале выводятся символы.

Для преобразования между базовыми типами данных (например, из char в int или наоборот) мы используем приведение типа, называемое статическим приведением.

image::7.png[]

Однако, как мы видим на рисунке 6, при сложении 1 + (-6) мы получаем 251, а не -5. Это можно объяснить тем, что переменная char вмещает 256 символов с диапазоном от 0 до 255. То есть в первом случае мы вышли за диапазон и наше число -5 отсчитывается с конца и принимает значение 251. Во втором случае при сложении 250+10 мы получили 4, а не 260, так как мы снова вышли за диапазон (рисунок 7).

.Выход за диапазоны
image::8.png[]

=== Запуск проекта в режиме симуляции

* Запустим проект на выполнение симулятором, посмотрим листинг окна *Disassembly*.

.Проект в режиме отладки
image::9.png[]

На рисунке 8 видим код программы СИ++ и окно *Disassembly*.
При нажатии на кнопки (_F10_, _F11_) мы проходим каждую строчку кода и перемещаемся в окне Disassembly. Здесь же мы можем увидеть, где создаются переменные.

* Добавим переменные в окне *Watch*, сделаем пошаговую отладку, посмотрим, как меняются переменные.


.Переменные в окне *Watch*
image::10.png[]


На рисунке 9 в окне *Watch* показаны значения, которые принимаю переменные (в виде символа и численного значения в 16-ричном коде). Например введенному числу -6 соответствует символ "ъ" и число FA (Hex) или 250 (Dec).

* Заупустим окно *Registers*

В окне *Registers* можно посмотреть значения регистров, в которых созданы переменные. Например в регистре _R0_, в котором создана переменная j = -6 лежит значение FA.

.Значения регистров в окне *Registers*
image::11.png[]

=== Вопросы по разделу

*1.* Дайте определение понятию “Интегрированной среде разработки”

*Ответ*:
интегрированная среда разработки (IDE) -  программный продукт, используемый для разработки ПО, и объединяющий в себе редакторы связей (линковщики, компоновщики), отладчики, более совершенные трансляторы, компиляторы и другие программные средства.

*2.* Что такое компилятор и чем он отличается от транслятора?

Ответ: Компилятор - специальный программный инструмент, который переводит код на каком-либо языке программирования в "машинный код".

Транслятор - обслуживающая программа, преобразующая исходную программу, предоставленную на входном языке программирования, в рабочую программу, представленную на объектном языке.

Компилятор отличается от транслятора тем, что его результирующая программа всегда должна быть написана на языке машинных кодов или на языке ассемблера.

*3.* Что такое компоновщик и какие функции он выполняет?

Ответ: Компоновщик - инструментальная программа, которая производит компоновку («линковку»): принимает на вход один или несколько объектных модулей и собирает из них исполняемый файл, который можно запустить на микроконтроллере.

*4.* Почему важен процесс проектирования ПО какие задачи входят в этот процесс?

Ответ: Проектируя ПО заранее, разработчик получает возможность: оценить стоимость и время разработки программного продукта, исключить потери времени и денег на ненужные действия, вынужденные доработки, длительное согласование, избежать разногласий и неудовлетворённости клиента и исполнителя.

*Задачи* процесса проектирования: выбор стратегии решения; выбор представления внутренних данных; разработка основного алгоритма; создание документации; тестирование; выбор представления входных данных.

*5.* Дорисуйте процесс разработки ПО, описанный на изображении IAR_Workbench с учетом итеративности связей в этом процессе

Ответ:

image::12.png[]

*6.* Зачем нужна отладка и в каких случаях она применяется? Для чего применяются точки остановки?

Ответ: отладка используется для нахождения ошибок, появляющихся при написании кода. Для того чтобы посмотреть как работает программа.

Точки остановки устанавливаются везде, где нужно приостановить выполнение отладчика. Например, вы хотите просмотреть состояние переменных кода или стек вызовов в определенной точке остановки.

*7.* Какие еще важные характеристики IAR Workbench можно добавить в таблицу *Характеристики IAR*

Ответ: большая база документации, поддержка микроконтроллеров большого числа известных фирм, возможность работы напрямую с регистрами.



