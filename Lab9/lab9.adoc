:imagesdir: Images
:figure-caption: Рисунок
:table-caption: Таблица
:toc:
:toc-title: ОГЛАВЛЕНИЕ:
== Лабораторная работа 9



=== Задание:

* Измерить температуру в комнате с помощью АЦП и инженекторных каналов.
* Значения температуры передать через UART и отобразить в программе Terminal.


=== 1. Настройка АЦП и вывод температуры

Для преобразования сигнала, полученного со встроенного в микроконтроллер датчика температуры, в цифровой код используется АЦП.

*Аналого-цифровой преобразователь* (АЦП) – устройство, которое принимает аналоговые сигналы и генерирует соответствующие им цифровые сигналы, пригодные для дальнейшей обработки микропроцессором или другим цифровым устройством.

Для преобразования сигналов, где нужна высокая точность применяется _сигма-дельта АЦП_. Но в основном микроконтроллеры содержат в себе АЦП _последовательного приближения_ (_SAR_).

Согласно документации встроенный температурный сенсор передает напряжение на 18 канал.

.Канал для temperature sensor
image::1.png[]

.Настройка регистра последовательного преобразования
image::3.png[]
image::4.png[]

* Код настройки АЦП:

[source,c]
----
 //Переключение на частоту ADC1

   RCC::APB2ENR::ADC1EN::Enable::Set();

   //Переключение на температурный сенсор

   ADC_Common::CCR::TSVREFE::Enable::Set();

   //Установка режима одиночного преобразования

   ADC1::CR1::RES::Bits12::Set();
   ADC1::CR2::CONT::SingleConversion::Set();
   ADC1::CR2::EOCS::SingleConversion::Set();

   // Установка частоты диспретизации в 84 цикла для 18 каналa

   ADC1::SMPR1::SMP18::Cycles84::Set();

   // Установка длины последовательного преобразования на 1

   ADC1::JSQR::JL::Conversion1::Set();

   // Установка первого преобразования на 18 канал

   ADC1::JSQR::JSQ4::Set(18);

  return 1;
}
}
----

==== 1.1 Нахождение температуры по линейному уравнению

Преобразовать код с АЦП в температуру можно по формуле, показанной на рисунке 3.

.Формула для раcчета температуры
image::2.png[]

.Числовые значения необходимых точек
image::5.png[]

* Температура определяется по некоторой прямой, заданной уравнением

y = k*x + b,

где y - искомая температура; x - код, полученный с АЦП (максимум 4096, т.к. разрядность 12 бит).

Рассчитаем коэффициенты k и b:

[source,c]
----
constexpr float B1 = (25.0F - 0.76F/0.0025F);
constexpr float K1 = (3.3F/4095.0F)/0.0025F;
----

* Выведем измеренную датчиком температуру в Terminal I/О.

.Код с АЦП и температура
image::6.png[]

* Листинг кода функции *main()*:

[source,c]
----
int main(void)
{
std::uint32_t data = 0U;

  // Включим ADC1

  ADC1::CR2::ADON::Set(1);

  for(;;)
  {
    // **************ADC*****************

    // Запуск преобразования на регулярном канале

    ADC1::CR2::SWSTART::On::Set();

    //Дожидаемся пока преобразование не завершится
    while(ADC1::SR::EOC::ConversionNotComplete::IsSet())
    {
    }

    //Получаем код с ADC

    data = ADC1::DR::Get(); //Get data from ADC;

    //Преобразуем АЦП код в температуру и выводим в Terminal

    std::cout << "Count: " << data << " Temperature_C: " << static_cast<float>(data) * K1 + B1 << std::endl;

    temp = std::to_string(static_cast<float>(data) * K1 + B1);
  }
}
----

==== 1.2 Нахождение температуры по калибровочным точкам

Для перевода кода АЦП в температуру можно использовать калибровочный точки, указанные в datasheet на микроконтроллер. Есть адреса двух точек, по которым лежат значения кодов температуры при 110 и 30 градусах цельсия.

.Адреса калибровочных точек
image::7.png[]

* Код функции *main()* показан ниже:

[source,c]
----
int main(void)
{
std::uint32_t data = 0U;

  // Для откалиброванной температуры

  float Temperature_calib = 0.0F;
  uint16_t *CAL1 = (uint16_t *)0x1FFF7A2C;
  uint16_t *CAL2 = (uint16_t *)0x1FFF7A2E;

  // Включим ADC1

  ADC1::CR2::ADON::Set(1);

  for(;;)
  {
    //**************ADC*****************

    //Запуск преобразования на регулярном канале

    ADC1::CR2::SWSTART::On::Set();

    // дожидаемся пока преобразование не завершится
    while(ADC1::SR::EOC::ConversionNotComplete::IsSet())
    {
    }

    //Получаем код с ADC

    data = ADC1::DR::Get(); //Get data from ADC;

    //Преобразуем код АЦП в температуру и выводим в Terminal

    std::cout << "Count: " << data << " Temperature_C: " << static_cast<float>(data) * K1 + B1 << std::endl;

    // Для откалиброванных значений

    Temperature_calib = (((float)(110-30)/(*CAL2-*CAL1)*((float)data - *CAL1))+30);

    std::cout << "Count: " << data << " Temperature_calib: " << Temperature_calib << std::endl;

  }
}
----

На рисунке 7 показан результат работы программы (Temperature_C - неоткалиброванная температура, Temperature_calib - откалиброванная).

.Вывод откалиброванной и неоткалиброванной температуры
image::8.png[]

=== 2. Передача температуры по UART и вывод в программе Terminal v1.9b

 С помощью программы Terminal v1.9b можно отправлять и принимать данные через COM порт компьютера по протоколу RS232.

Для настройки и работы модуля UART нужно всего несколько регистров:

* USART_CR1/CR2/CR3 -  регистр настройки 1
* USART_DR -  регистр принятого символа (регистр данных)
* USART_BRR – регистр настройки скорости передачи
* USART_SR  - регистр состояния

Порядок запуска модуля UART:

* Подключить USART к источнику тактирования – устанавливаем бит USART2EN в регистре APB1ENR (АЦП тактируется от матрицы шин APB1).
* Необходимо сконфигурировать порты. Настроить порты, на альтернативную функцию нужного модуля USART
* Настроить формат передачи байт, с помощью регистра CR1 и CR2
* Задать скорость передачи с помощью регистра BRR
* Разрешить передачу помощью бита TE и если надо прием, с помощью бита RE в модуле USART с помощью регистра CR1
* Включить сам модуль USART битом UE  в регистре CR1

[source,c]
----

//Порт А к системе тактирования

  RCC::AHB1ENR::GPIOAEN::Enable::Set();

  //Порт А2 и А3 на альтернативный режим работы

  GPIOA::MODER::MODER2::Alternate::Set();
  GPIOA::MODER::MODER3::Alternate::Set();

  //Назначение портов А2 и А3 на альтернативную функцию 7
  GPIOA::AFRL::AFRL2::Af7::Set();  // USART2 Tx
  GPIOA::AFRL::AFRL3::Af7::Set();  // USART2 Rx

  //Подключаем USART2 к системе тактирования APB1
  RCC::APB1ENR::USART2EN::Enable::Set();

  USART2::CR1::OVER8::OversamplingBy16::Set();
  USART2::CR1::M::Data8bits::Set();
  USART2::CR1::PCE::ParityControlDisable::Set();

  USART2::BRR::Write(8'000'000 / 9600); // 8 МГц с внешнего генератора HSE
  USART2::CR1::UE::Enable::Set();
----
