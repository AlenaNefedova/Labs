:imagesdir: Images
:figure-caption: Рисунок
:table-caption: Таблица
== Лабораторная работа 4

=== Задание:
* Написать программу, которая моргает *всеми 4 светодиодами* через прямой доступ к памяти по адресам.
 *  Описать как работает операция *исключающее ИЛИ* и как поменять значения переменных местами, без привлечения третьей переменной.

=== 1. Работа с платой

Необходимо, чтобы *4* светодиода, подключенных к портам *C.5, C.8, C.9, A.5*, одновременно загорались и гасли с частотой *1 Гц.*

* Запустим проект из прошлой лабораторной работы.

В предыдущей работе светодиоды включались через команду, например для порта А.5, GPIOA::ODR::ODR5::High::Set().

Теперь надо реализовать мигание светодиода через прямой доступ к памяти по адресам. Для этого воспользуемся указателями через *.
Чтобы получить адреса для порта А и С можно нажать правой кнопкой мыши по слову ODR в коде программы и выбрать Go to Definition of "ODR". Внизу в меню появятся нужные адреса.

.Адреса линий GPIOA и GPIOС
image::1.png[]

С помощью конструкции reinterpret_cast преобразуем адрес 0x40020014 в указатель типа uint32_t. Затем для подключения порта А.5 с помощью логической операции *исключающего ИЛИ* (^) сдвинем единицу на 5 позиций влево (чтобы в пятом бите стояла единица). Реализуем задержку с помощью delay. Для того чтобы выключить светодиод используем ту же строчку, что и для включения. В данном случае исключающее ИЛИ меняет 0 на 1 или 1 на 0. Тоже самое можно сделать используя операций *или* |, а затем *и не* & ~.

Код программы:

[source,c]
----
int main()
{
    //Подать тактирование на порт А
    RCC::AHB1ENR::GPIOAEN::Enable::Set();
    //Подать тактирование на порт C
    RCC::AHB1ENR::GPIOCEN::Enable::Set();
    //Порта A. 5 на вывод
    GPIOA::MODER::MODER5::Output::Set();
    //Порта C.5, C.8, C.9 на вывод
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();

    for(;;)
    {
        uint32_t* ptrPaOdr = reinterpret_cast<uint32_t*>(0x40020014);

        *ptrPaOdr ^= static_cast<uint32_t>(1 << 5);

        //1 << 5 = 000000b | 000010000b = 000010000b

        /*
        *ptrPaOdr |= static_cast<uint32_t>(1 << 5);
        *ptrPaOdr &=~ static_cast<uint32_t>(1 << 5);
        */

        uint32_t* ptrPcOdr = reinterpret_cast<uint32_t*>(0x40020814);

        *ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 8);


        delay(1000000);
        *ptrPaOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 5);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 9);
        *ptrPcOdr ^= static_cast<uint32_t>(1 << 8);
        delay(1000000);
    }

    return 1;
}
----

Откроем окно Registers и посмотрим как меняются значения в регистрах.

При включении светодиода в регистре устанавливается единица, при выключении единица сбрасывается и устанавливается 0. Аналогично и для других светодиодов.

.Значение регистра ODR5 при включенном светодиоде порта А.5
image::2.png[]

Результат работы программы приведен на рисунке 3.

.Мигание всех 4 светодиодов
image::1.gif[]

=== 2. Операция исключающее ИЛИ

* Побитовое *исключающее ИЛИ* (^) (сокр. «XOR» от англ. «eXclusive ORR»).
Таблица истинности для исключающего ИЛИ:

.Исключающее ИЛИ
[options="header"]
|=========
|A|B|A xor B
|0|0|0
|0|1|1
|1|0|1
|1|1|0

|=========

Оператор побитового исключающего или (^) сравнивает каждый бит своего первого операнда с соответствующим битом второго операнда. Если бит одного из операндов равен 0, а бит второго операнда равен 1, соответствующий бит результата устанавливается в значение 1, в противном случае - нулю.

Присваивание с побитовой операцией исключающего ИЛИ выполняется с помощью символов ^=.

Например, вместо х = x ^ y; мы можем написать x ^= y.

* Чтобы поменять значение двух переменных местами можно воспользоваться операцией исключающее ИЛИ.

Например, дано: a=3, b=4. Нужно получить a=4, b=3.

Код программы:

[source, c]
----
#include <iostream>
int main()
{
  int a=3, b=4;
  a ^= b ^= a ^= b;
  std::cout <<"a = " << a << std::endl;
  std::cout <<"b = " << b << std::endl;
  return 1;
}
----

.Результат работы программы
image::0.png[]

*Объяснение работы программы:*

Цифра 3 в двоичном коде представлена как 011. Цифра 4 в двоичном коде 100.

* Сначала выполняется операция a = a ^ b = 011 ^ 100 = 111.
* Затем выполняется операция
*b* = b ^ a = 100 ^ 111 = *011*.
* После этого *a* = а ^ b = 111 ^ 011 = *100*.

В результате, как видно, переменные поменялись местами.